### 一、 项目概述

本软件是一个纯本地运行的桌面端 AI 效率工具。核心目标是实现“输入 B站视频链接 -> 自动提取音频 -> 语音转文字 -> AI 智能总结 -> 本地持久化存储与文件导出”的全自动化工作流。解决用户快速获取长视频核心信息、制作学习笔记的需求。

------

### 二、 核心功能模块与细节把控

**模块 1：链接输入与音频下载**

- **输入校验：** 界面提供输入框，支持识别标准 B站链接（`bilibili.com/video/BV...`）及短链。
- **信息抓取：** 自动获取视频标题，用于后续的命名和数据库存储。
- **音频提取：** 仅下载音频流（M4A 或 MP3 格式），跳过视频画面下载以节省带宽和时间。
- **本地缓存：** 在项目根目录建立 `/downloads` 文件夹，按“视频标题+时间戳”命名保存音频文件。

**模块 2：语音转文字 (ASR)**

- **状态提示：** UI 界面需显示“正在识别语音，请稍候...”的状态提示（Spinner）。
- **长音频切片（关键细节）：** 大多数第三方 ASR API（如 OpenAI Whisper）有 25MB 的文件大小限制。若采用 API 方案，代码中需加入音频按时长或大小自动切片（Chunk）的逻辑，分别识别后再拼接。若采用本地离线模型（如 Faster-Whisper），则无需切片。

**模块 3：大模型智能总结 (LLM)**

- **Prompt 设计：** 将拼接好的完整转录文本发送给大模型。需内置系统提示词（System Prompt），例如：“你是一个专业的笔记助手，请根据以下视频转录文稿，提取核心观点，按‘内容摘要’、‘核心亮点’、‘结论’三个部分输出”。
- **长文本支持（关键细节）：** 1 小时的视频转录文本极长。需选用支持长上下文（如 128k 窗口）的模型 API（推荐 DeepSeek、Kimi 或通义千问）。

**模块 4：本地数据库存储**

- **静默存取：** 整个工作流节点的数据实时落盘，防止软件意外关闭导致进度丢失。
- **历史记录展示：** 界面左侧或独立 Tab 提供“历史任务列表”，点击历史记录可直接查看过往的转录原文和总结，无需重复消耗 API 额度。

**模块 5：结果展示与文件导出**

- **双栏/分块展示：** 界面清晰区分“原始转录文本”和“AI 总结结果”。
- **一键导出：** 提供两个下载按钮：【下载完整逐字稿 (.txt)】 和 【下载总结笔记 (.md)】。

------

### 三、 数据库设计 (SQLite)

数据库选用轻量级的 SQLite，单文件 `data.db` 存储。核心表命名为 `tasks`。

- `id` (主键，自增 INTEGER)
- `bilibili_url` (TEXT，视频原始链接)
- `video_title` (TEXT，视频标题)
- `audio_file_path` (TEXT，本地音频相对路径)
- `transcript_text` (TEXT，语音转文字的完整结果)
- `summary_text` (TEXT，AI 返回的总结结果)
- `status` (TEXT，当前任务状态：等待中 / 下载中 / 转录中 / 总结中 / 已完成 / 失败)
- `created_at` (DATETIME，任务创建时间)

------

### 四、 技术栈与依赖选型

- **编程语言：** Python 3.10+
- **UI 框架：** Streamlit (极简的纯 Python 前端框架，自带交互组件和下载按钮)
- **下载核心：** `yt-dlp` (当前最强视频下载库，完美支持 B站提取音频)
- **音频处理：** `pydub` (用于处理 ASR API 限制情况下的音频切片)
- **数据库引擎：** `sqlite3` (Python 内置)
- **网络请求与 API 客户端：** `openai` (官方库，可用于兼容 OpenAI 格式的各类大模型 API)

------

### 五、 异常处理与边界情况 (风险控制)

- **B站大会员/高画质限制：** 某些视频可能需要登录态。`yt-dlp` 支持传入浏览器 Cookie 文本。需在代码中预留读取 `cookie.txt` 的接口，防止下载被拦截。
- **API 网络超时：** 语音识别和大模型总结环节耗时较长，必须设置合理的 Timeout（建议 60-120 秒），并配合 `try-except` 捕获异常，在 UI 上向用户提示具体的错误信息（如“API 余额不足”或“网络连接失败”），并允许一键重试失败的节点，而不是从头开始下载。
- **本地文件清理：** 提供一个“清理缓存”按钮，用于删除 `/downloads` 文件夹下早于一定时间（如 7 天前）的音频原文件，释放硬盘空间。

非常有远见！在写下第一行代码之前先规划好项目目录和架构，是区分“业余脚本”和“专业软件”的关键。这不仅能让代码更易于维护和扩展，还能在排查 bug 时迅速定位问题。

对于这个纯本地版的 Python + Streamlit 应用，我们应该遵循**“高内聚、低耦合”**的原则，将用户界面（UI）、核心业务逻辑（Core）和数据存储（DB）严格分层。

以下是我为您在需求文档中补充的**《六、 系统架构与代码目录规范》**：

------

### 六、 系统架构与代码目录规范

本项目采用分层架构设计，确保各个功能模块独立解耦。整体项目目录树 (`Tree`) 规划如下：

Plaintext

```
bili-summary-tool/
├── app.py                 # (表现层) Streamlit UI 的主入口文件
├── config.py              # (配置层) 全局配置、环境变量加载、常量定义
├── requirements.txt       # (依赖层) Python 第三方库清单
├── .env                   # (安全层) 本地存放 API Keys 等敏感信息 (不提交Git)
│
├── core/                  # (业务逻辑层) 核心功能模块，不包含任何 UI 代码
│   ├── __init__.py
│   ├── downloader.py      # 负责调用 yt-dlp 解析和下载音频
│   ├── transcriber.py     # 负责处理音频切片、调用 ASR 服务转录文字
│   └── summarizer.py      # 负责组装 Prompt、调用 LLM API 生成总结
│
├── db/                    # (数据访问层) 专门负责与 SQLite 交互
│   ├── __init__.py
│   └── database.py        # 包含数据库初始化、建表、各类 CRUD (增删改查) 函数
│
├── utils/                 # (通用工具层) 存放复用性高的辅助函数
│   ├── __init__.py
│   ├── file_helper.py     # 负责本地目录检查、文件重命名、清理过期音频文件
│   └── logger.py          # (可选) 自定义日志格式，方便在终端查看运行状态
│
├── data/                  # (持久化存储) 本地数据库目录
│   └── app.db             # SQLite 数据库文件 (程序首次运行时自动生成)
│
└── downloads/             # (临时存储) 音频文件暂存区
    └── ...                # 下载的 .m4a / .mp3 文件 (程序运行时自动生成)
```

#### 各模块功能区块划分详解

**1. 表现层 (Presentation Layer) -> `app.py`**

- **职责：** 仅负责“画界面”和“接收用户输入”。
- **原则：** 绝对不要在 `app.py` 里直接写 `sqlite3.connect()` 或者 `requests.post()`。它应该像一个指挥家，只负责调用 `core` 和 `db` 里的函数，并将结果展示在网页上。管理 Streamlit 的 `session_state` 以保持页面刷新时的数据状态。

**2. 业务逻辑层 (Business Logic) -> `core/` 目录**

- **`downloader.py`：** 封装一个 `download_audio(url)` 函数。输入 B 站链接，内部处理所有下载逻辑，最终返回本地音频文件的绝对路径。
- **`transcriber.py`：** 封装一个 `audio_to_text(file_path)` 函数。负责读取音频文件，（如果太大就切片），发送给语音识别 API，最后拼接并返回完整的字符串。
- **`summarizer.py`：** 封装一个 `generate_summary(text)` 函数。负责把长文本和系统提示词（System Prompt）组合，发送给大模型，返回总结结果。

**3. 数据访问层 (Data Access) -> `db/database.py`**

- **职责：** 隔离所有 SQL 语句。
- **设计：** 提供清晰的函数接口，如 `init_db()`（初始化建表）、`create_task(url, title)`（创建新任务记录）、`update_task_status(task_id, status)`（更新任务状态）、`get_all_tasks()`（获取历史记录）等。供 `app.py` 随时调用。

**4. 配置与工具层 (Config & Utils)**

- **`config.py`：** 使用 `python-dotenv` 库读取 `.env` 文件。集中管理如 `DOWNLOAD_DIR = "./downloads"`、`MAX_AUDIO_SIZE_MB = 25` 这样的常量，避免代码里到处都是硬编码的魔法数字（Magic Numbers）。